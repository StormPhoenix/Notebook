---
id: 6uyp521qc2npimrhkq9kunj
title: UMG
desc: ''
updated: 1688580166917
created: 1686831231691
tags:
    - UMG
---

### 用法
参考：[UMG 最佳实践](https://docs.unrealengine.com/5.2/en-US/umg-best-practices-in-unreal-engine/)
- UI 界面的设计。如何添加 Widget 到画布；UI 布局 layout。
- UI 编辑器功能区介绍。
- Widget 的事件触发。

# 组件

## TextBlock

参考: [UMG 组件 - TextBlock](https://zhuanlan.zhihu.com/p/136463055)

## Button
用于用户点击，主要关注四种背景状态
- Normal：普通状态
- Hovered：鼠标悬停状态
- Pressed：鼠标按下时状态
- Disabled：按钮无效状态

参考：[UMG 组件 - Button](https://zhuanlan.zhihu.com/p/102089811)

## Image 
常用作背景板、按钮按下前后 UI 状态切换，具体参考: [UMG 组件 - Image](https://zhuanlan.zhihu.com/p/136472896?utm_medium=social&utm_oi=1565688472064749568&utm_psn=1657724344171253760&utm_source=ZHShareTargetIDMore)。

## ListView
参考: UIFaceRoleView [ListView 详解](https://zhuanlan.zhihu.com/p/127184008)

ListView 功能的运行需要三个对象：
- ListView：UI ListView
- ListEntry：自定义 UI 组件
- ListItem：数据对象，需要继承 IUserObjectListEntry 接口。

一般用户自定义了 ListEntry UI 组件后，为了方便，会直接让其继承 IUserObjectListEntry 接口。

ListViewWidget 需和 ListEntryWidget 配合使用。

ListView 找到 List Entries 选项，设置 ListEntry，将 List 和 Entry 关联起来。

作为 List Entry 的 Widget 需实现 IUserObjectListEntry 接口，该接口包含几个常用方法 
- OnListItemObjectSet：当 item 数据被传入 List Entry 时触发，用户需实现该方法来设置自身的 UI 状态。
- OnItemSelectionChanged：当 item 选中状态被改变时触发。

ListView 的相关接口
- OnItemSelectionChanged：ListView 管理的 item 被选中时触发

### 接口调用顺序
1. ListView 创建：
forloop(ListEntry::OnListItemObjectSet => ListView::OnEntryInitialized) 
=> ListView::OnEntryGenerated

2. ListView 选中某个 item
=> ListEntry::OnItemSelectionChanged 选中状态为 true
=> ListEntry::OnItemSelectionChanged 选中状态为 false
=> ListView::OnItemSelectionChanged 选中状态为 true

3. ListView 滑动过程中 ListEntry 消失
=> ListView::OnEntryReleased

## Layout
可作为容器填充子 Widget，负责管子 Widget 布局。布局组件有多种，包括：Canvas Planel、Overlay Slot、Vertical Box、Horizontal Box。

每个添加到布局组件中的子 Widget，都会新增一个 Slot 属性项，用来定义子 Widget 在 UI 上的位置。因此只要重点关注 Slot 就可以了。

### Canvas Planel
新增 Slot (Canvas Planel Slot)，这种情况下要定义好子 Widget 的 Anchor、Size、Position、Alignment，就能确认子 Widget 的大小。

Anchor：子组件的对齐方式（左上、右上、居中等）
ZOrder：当子 Widget 们存在重叠时，ZOrder 决定绘制顺序

### Overlay 
新增 Slot (Overlay Slot)，子组件只有两种对齐模式：Vertical Alignment 和 Horizontal Alignment。

### Vertical Box
新增 Slot (Vertical Box Slot)，让子组件垂直布局，水平方向采用 Horizontal Alignment，相当于 Overlay 在垂直方面的特化。
子组件的 Size 有两种决定方式：Auto 和 Fill。
- Auto：子组件自己决定大小
- Fill：子组件在水平、垂直方向上填充 Vertical Box，其中垂直方向上需要设置填充比例，用来和其他子组件划分 Vertical Box 空间。
此外还有一个 Alignment 属性用来决定子组件在 Vertical Box 里面的对齐方式。这里需要注意 Size 和 Alignment 之间的区别：Size 是你从容器中获得的空间，Alignment 决定空间的分配。

### Horizontal Box
Horizontal Box 让子组件水平布局，垂直方向采用 Vertical Alignment，相当于 Overlay 在水平方面的特化，其余用法同 Vertical Box。

### Size Box
Size Box 设置了固定 Size 限制了子组件大小。一些子组件的大小可能不符合用户的期望，这类组件可以在外层套上 Size Box 容器来限制大小
新增 Slot (Size Box Slot)，可设置属性包括：Padding、Horizontal\Vertical Alignment。

# UMG 的渲染 - Slate Renderer \ UMG Renderer

[虚幻4渲染编程（UI篇）【第一卷：Slate框架综述】](https://zhuanlan.zhihu.com/p/45682313) 检查 UI 产生的 DC

[虚幻5渲染编程 (UI篇)【第一卷: Slate渲染框架并通过为UMG拓展MeshUI了解Slate的图元阶段】](https://zhuanlan.zhihu.com/p/387752531) UE 的 UI 为了编辑器牺牲了太多？

SImage -> SLeafWidget ->SWidget
SOverlay -> SPanel -> SWidget

## Slate 绘制的几个阶段

## UI 元素抽象结构

- FDrawWindowArgs
  - FSlateDrawBuffer: 保存 UI 元素列表
    - TArray<TSharedRef<FSlateWindowElementList>> WindowElementLists: SlateWindow 列表存储位置

- FSlateDrawElement: Slate 将所有可见的 UI 抽象成 FSlateDrawElement 的列表。FSlateDrawElement 保存绘制的 Position、绘制的元素类型。每个 SlateWindow 保存各自的 UI Element 列表，而 FSlateDrawElement 作为 FSlateWindowElementList 的元素列表而存在。

- FSlateElementBatcher：收集 UI Element 的顶点 Buffer，FSlateElementBatcher::AddElementsInternal() 判断添加的 UI Elements 类型。执行打包收集顶点数据操作

- FSlateBatchData：FSlateElementBatcher 添加的 顶点数据被填充到 FSlateBatchData 的 RenderBatches(FSlateRenderBatch) 变量

调用入口从何处看起：
- 收集每个 Window 里的 UI 元素，以及顶点数据部分：
  - PrivateDrawWindow -> DrawWindowAndChildren() 收集每个 Window 里面的 UI Element，保存类型
  - Renderer->DrawWindows(FSlateDrawBuffer) 收集每个 UI Element 的顶点、索引数据

#### 顶点数据收集过程调用堆栈

逻辑侧，UI 以树为组织单位，依靠 SWidget::Paint() & SWidget::OnPaint() 做深度递归。第一级递归开始传入 FDrawWindowArgs，后续递归过程将收集 UI 元素填充进 FDrawWindowArgs::FSlateDrawBuffer::WindowElementList 里面。

FEngineLoop::Tick() -> FSlateApplication::Tick() ->FSlateApplication::TickAndDrawWidgets()
- DrawWindows() -> PrivateDrawWindow()
  - DrawWindowAndChildren() 最先从 FSlateApplication 开始调用，遍历位于最顶端的窗口元素 SlateWindows 变量
    (经过多次 SWidget::Paint() 和 SXXX::OnPaint() 之后，最后位于 UI 树木根节点的 SXXX::OnPaint())
    - SImage::OnPaint() (叶节点以 SImage 为例) -> FSlateDrawElement::MakeBox()
      - 判断该 UI 是否需要裁剪(调用 ShouldCull())，比如全透明的 UI 需要裁掉。
- DrawWindows() -> Renderer::DrawWindows(OutDrawBuffer) -> FSlateRHIRenderer::DrawWindows_Private(OutDrawBuffer)
  - FSlateElementBatcher::AddElements() -> FSlateElementBatcher::AddElementsInternal() 上文收集到的 Window 里的 UI 组件逐个遍历，判断其类型(ET_Box、ET_RoundedBox 等) 来添加顶点数据。
    - AddXXXElement() 判断 UI 类型后调用不同的 AddXXXElement() 函数，例如 AddBoxElement()、AddTextElement()
      - CreateRenderBatch() 创建一个 RenderBatch (UI 批处理对象)，里面有 UI 的顶点数据。
      - 用 Vertex/Index 数据填充上面的 RenderBatch。提一下 Text 是如何处理的，他是直接填充了两个三角形绘制，文字用材质来表示，参考：ElementBatcher.cpp line 1126
  - 每遍历到一个 Window，就触发 DrawWindow_RenderThread()，把 UI Element 提交到渲染线程绘制。

## Slate 渲染器

继承结构：
FSlateRenderer
- FSlateRHIRenderer
- FSlateOpenGLRenderer

最终调用位置是：DrawWindows_Private() -> DrawWindow_RenderThread()
STAT_SlateRenderingRTTime

# Slate 相关统计指令与优化

## Slate 指令
Num Painted Widgets: 执行 OnPaint 的数量
Num Batches: Draw Call

## 优化方案
### Game Thread 优化
- Invalidation Box 优化：缓存渲染信息，子组件更新时重新调用 Paint
- Visibility 优化
- Widget Binding 每帧执行，性能较低；
  - Tick 中复杂的运行逻辑移动到 C++

### Render Thread 优化
#### 合批的条件
参考：https://zhuanlan.zhihu.com/p/529040584
1. 组件 LayerId。组件根据 LayerId，从小到大排序，LayerId 不同不能合批。
2. IsBatchableWith() 返回值为 True，否则不能合批次。

TODO: 重点关注下排序的位置。

合批的位置：
1. FSlateRHIRenderer::BuildRenderingBuffers()。从代码中看出 Slate 合批不是 Instance 合批，而是 VertexBuffer 和 IndexBuffer 合批。

- Retained Box 优化：用 RT 缓存渲染信息
- Canvas Plane 开启合批，每个子 Widget 如果 ZOrder 相同，则会合并批次。
- 贴图合并 UPaperSprite
- Retainer Box: 缓存 UI 渲染到 RT，只要子控件树没有更新，每次 OnPaint 只提交缓存的 RT，跳过全部子组件的 Paint 流程，适用于占用大量像素率的情况；重复使用的 UserWidget 不要使用 Retainer Box，不然会生产许多 RT

- 优化工作应该再后期进行

参考：
- https://docs.unrealengine.com/5.0/en-US/understanding-the-slate-ui-architecture-in-unreal-engine/
- https://gwb.tencent.com/community/detail/113852
- https://www.cnblogs.com/hggzhang/p/16480489.html
- https://zhuanlan.zhihu.com/p/529040584
- https://blog.csdn.net/qq_21919621/article/details/108574372
- RetainerBox 优化 https://zhuanlan.zhihu.com/p/532401520



TODO:
- UMG 的数据绑定
- UMG ViewModel https://docs.unrealengine.com/5.2/zh-CN/umg-viewmodel
- Invalidation Box https://blog.51cto.com/u_15075510/3795050