---
id: kpdolholylns5ns3uw6mypq
title: 渲染流程与数据组织框架
desc: ''
updated: 1688126228131
created: 1688092844232
---

# 案例学习
## 案例一
https://zhuanlan.zhihu.com/p/36635394

https://zhuanlan.zhihu.com/p/36695496

关键点：
1. 创建 Shader 类继承 GlobalShader，编写 Shader 代码。用宏 IMPLEMENT_SHADER_TYPE 将 Shader 类和 Shader 代码联系起来。
   1. Shader 代码中的 float 变量(SimpleColor)对应到 Shader 类的成员变量(SimpleColorVal)，类型为 FShaderParameter，Shader 类构造函数里用 Initializer.ParameterMap 把两个变量绑定起来；
   2. Shader 类内部调用 SetShaderValue() 给 SimpleColorVal 赋值，相当于更新了 Shader 代码中的 SimpleColor；
2. 设置渲染前准备工作，包括渲染目标(RenderTarget)，设置渲染状态(FGraphicsPipelineStateInitializer，即 Pipeline State Object，简称PSO)，更新 Shader 类参数，准备网格顶点数据。
   1. 获取 RenderTarget，着色器执行结果输出的位置，该案例中结果输出到纹理。
   2. 创建 PSO，这里只关注设置 Shader 的部分。用了 GetGlobalShaderMap() 函数获得定义好的 Shader 类对象，将其赋值给 PSO，这样后续执行渲染时，Shader 代码就能运行起来了。
   3. 更新 Shader 参数。内部调用了 SetShaderValue() 函数更新了 Shader 代码中定义的 SimpleColor 变量的值。
   4. 创建顶点数据。简单创建了一个 float 数组，用于存储顶点数据
3. 执行渲染。案例用了 RHICmdList 类，这里把 RenderTarget，PSO 传给了 RHICmdList，不知道其原理，只知道可以用于后续执行绘制。再把 RHICmdList 和顶点数据传入 DrawIndexedPrimitiveUP()，就可以执行绘制了。

UE 相关解释：
- ENQUEUE_RENDER_COMMAND 宏: [[阅读笔记.UnrealEngine.渲染流程与数据组织框架#enqueue_render_command]]
- RHICmdList: [[阅读笔记.UnrealEngine.渲染流程与数据组织框架#rhicmdlist]]

总结：
- Shader 代码和 Shader 类的创建
- 渲染管线状态的设置
- 调用 UE 的绘制 API 执行渲染
  
## 案例二
https://zhuanlan.zhihu.com/p/36696092

关键点：
1. 新增 Shader 代码入口函数参数，需要对应修改 VertexDecleration 和顶点数据
   1. 修改顶点数据。再顶点数组里增加 UV 坐标数据。
   2. FVertexDeclarationRHIRef。顶点数据在传输过程中是无结构的，因此 UE 需要知道顶点数据内部布局(即：偏移多少字节处是 Position 数据？偏移多少字节处是 UV 数据？)，才能把顶点数据和 Shader 代码的入口函数对应起来。具体做法是创建 FVertexDeclarationRHIRef 赋值给 PSO。
2. Shader 代码新增纹理、纹理采样器变量。处理方式和上文相同，也是用 InitializerMap 把 Shader 代码和 Shader 类的成员变量绑定起来。
   1. Shader 类新增纹理、纹理采样器变量，类型为 FShaderResourceParameter。
   2. 给纹理、纹理采样器变量赋值时采用了 SetTextureParameter() 而不是 SetShaderValue()。

UE 相关解释：
- Shader 参数及赋值方式 [[阅读笔记.UnrealEngine.渲染流程与数据组织框架#shaderparameter]]
- VertexDecleration 参考 [[阅读笔记.UnrealEngine.渲染流程与数据组织框架#vertex-buffer-与-vertex-declarationrhi]]

## 案例三
https://zhuanlan.zhihu.com/p/36696626

关键点：
1. UniformBuffer 数据。Shader 代码新增 Uniform 参数，Shader 类应做如下设置
   1. C++ 端声明定义 Uniform。和一般 float\Texture、TextureSampler 变量不同，Uniform 变量需要通过宏声明(UE5 之后宏变动很大，参考[[阅读笔记.UnrealEngine.渲染流程与数据组织框架#shaderparameter]])定义。
   2. UE 自己会自动生成该 Uniform 的 HLSL 代码，和 C++ 端定义的 Uniform 对应绑定起来，因此不需要用户手动在 Shader 代码中定义 Uniform，也不需要在 Shader 类中做绑定。
   3. 修改 Uniform 的值要用 SetUniformBufferParameterImmediate() 函数。

总结：
- 用宏声明定义 UniformBuffer，用 SetUniformBufferParameterImmediate() 修改 UniformBuffer 值。

## 案例四
https://zhuanlan.zhihu.com/p/36697128
https://zhuanlan.zhihu.com/p/53836725

关键点：
1. Compute Shader 的执行不需要设置 PSO，但需要设置 RenderTarget
2. 新增 SRV\UAV 两类 Buffer。SRV 是只读 Buffer，UAV 是可读写 Buffer，参考[[阅读笔记.UnrealEngine.渲染流程与数据组织框架#shaderparameter]]。
3. 在 Buffer、Texture 之间复制数据前后，要用 RHILockXXX、RHIUnlockXXX 类函数处理
   1. RHILockBuffer/RHIUnlockBuffer
   2. RHILockTexture/RHIUnlockTexture

## 案例五
https://zhuanlan.zhihu.com/p/61464613


# 绘制流程
（1）绘制资源准备 => （2）Shader 资源准备 => （3）执行绘制

什么是绘制资源
什么是 Shader 资源

# PSO

# ShaderBinding

# FVertexFactory
作用：
- 绑定 Shader 
- 绑定顶点数据 VertexBuffer 
- 其他需要绑定数据

## Vertex Buffer 与 Vertex Declaration
FVertexStreamComponent: 定义顶点格式，GPU 侧需要这个来确定如何读取顶点数据。
FRHIShaderResourceView: 保存实际的顶点数据。

以上由 FLocalVertexFactory::FDataType (或者其子类) 封装。

## Mesh 与 Vertex Buffer
示例：RenderData->VertexBuffer

# 附录
## ENQUEUE_RENDER_COMMAND
## RHICmdList
## ShaderParameter

Shader 中不同类型的变量在 C++ 端的定义、赋值对比

| Shader 代码类型 | C++ 定义 | C++ 端赋值方式 | 用于赋值的数据的类型 |
| ---- | ---- | ---- | ---- |
| float | FShaderParameter | SetShaderValue() | float | 
| Texture2D | FShaderResourceParameter | SetTextureParameter() | FTextureRHIRef |
| StructuredBuffer<T> | FShaderResourceParameter | SetSRVParameter() | FRHIShaderResourceView* |
| RWTexture2D | FRWShaderParameter | RHICmdList.SetUAVParameter() | FRHIUnorderedAccessView* |
| Uniform | 用 UE 宏声明类型，并定义 | SetUniformBufferParameterImmediate() | 用 UE 宏声明的类型 |


Uniform 的声明定义方式在 UE5 中已修改，使用如下宏：
 - BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT 定义全局 Uniform，需要 IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT
 - SHADER_PARAMETER、SHADER_PARAMETER_XXX
 - IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT
 - BEGIN_SHADER_PARAMETER_STRUCT 定义 Shader 内部的 Uniform

FShaderParameter、FShaderResourceParameter 在 Shader 类中的声明方式已经变成了用 LAYOUT_FIELD(FShaderParameter, ParamName) 声明定义。

遇到的许多 FRHI 类：
- 基类：FRHIBuffer, FRHITexture(他们的基类是 FRHIResource)
  - FTexture2DRHIRef, RHICreateTexture2D()
  - RWStructuredBuffer<T>, RHICreateStructuredBuffer()
  - FUnorderedAccessViewRHIRef, RHICreateUnorderedAccessView()


遇到许多 Shader Parameter 相关类：
- FShaderResourceParameter
- FRWShaderParameter
- FShaderParameter

他们之间的转化是：FRHIBuffer/FRHITexture 及其派生类对象 -> 经过 RHICreateUnorderedAccessView()/RHICreateShaderResourceView() 创建出 -> FRHIUnorderedAccessView/FRHIShaderResourceView -> 设置到 FShaderResourceParameter/FRWShaderParameter

## FRenderResource
## TGlobalResource